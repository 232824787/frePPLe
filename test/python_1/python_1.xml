<?xml version="1.0" encoding="UTF-8" ?>
<plan xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <description>
    This test case tests the embedded python interpreter.
    It verifies:
      - Executing Python code as XML processing instruction.
      - Executing Python code in a seperate source file.
      - Performance comparison of data loading in different ways.
      - Catching of exceptions thrown in frePPLe C++ code.
      - Executing Python code in different threads
  </description>
  <current>2007-01-01T00:00:00</current>
<?python
import sys, frepple
print "1. Python as a processing instruction"
myvariable = 4
print '1. defining my variable:', myvariable
print '1. frepple version:', frepple.version?>
  <commands>
  	<verbose>true</verbose>
  	<abortonerror>false</abortonerror>
    <command xsi:type="command_python" filename="python.py"/>
    <command xsi:type="command_python" filename="nowheretobefound.py"/>
    <command xsi:type="command_python">
      <cmdline>
<![CDATA[
print '3. retrieving a variable:', myvariable
print '3. calling a function:', my_function(myvariable)
]]>
      </cmdline>
    </command>
    <!--
    In the next steps we are comparing the speed of 3 types of APIs each
    achieving exactly the same final result:
     1) Frepple C++ to read a XML-datafile.
     2) Python to read a CSV-datafile, which is reformatted in memory
        into XML and passed to frePPLe as a string.
     3) Python to read a CSV-datafile, which then the calls the C++ API
        directly.
    The relative performance is pretty interesting:
     1) 3.06 sec
     2) 3.86 sec
     3) 2.43 sec
    These numbers are based on a file with 200000 items and 100 operations
    to create. The test is running on a 3.2GHz Intel Pentium (R) dual core
    Linux machine.
    Conclusion: The overhead of parsing of the verbose XML data format
    is considerable, even when coded in C++. Interpreted Python code can
    easily achieve better performance.
    Obviously a different test configuration will give different results.
    E.g. when running small XML messages rather than a huge data file...
    -->
    <command xsi:type="command_python">
      <cmdline>create_files(200000)</cmdline>
    </command>
    <command xsi:type="command_readxml" filename="items.xml" validate="false" />
    <command xsi:type="command_save" filename="afterXMLread.xml" />
    <command xsi:type="command_erase" mode="model" />
    <command xsi:type="command_save" filename="aftererase1.xml" />
    <command xsi:type="command_python">
      <cmdline>read_csv_file()</cmdline>
    </command>
    <command xsi:type="command_save" filename="afterCSVread.xml" />
    <command xsi:type="command_erase" mode="model" />
    <command xsi:type="command_save" filename="aftererase2.xml" />
    <command xsi:type="command_python">
      <cmdline>read_csv_file_direct()</cmdline>
    </command>
    <command xsi:type="command_save" filename="afterCSVDirectread.xml" />
    <command xsi:type="command_erase" mode="model" />
    <command xsi:type="command_save" filename="aftererase3.xml" />
    <command xsi:type="command_python">
      <cmdline>
<![CDATA[
print '4. a syntax error:'
wrong
]]>
      </cmdline>
    </command>
    <command xsi:type="command_python">
      <cmdline>
<![CDATA[
print '5. python catches exceptions thrown from the frepple C++ code'
frepple.readXMLfile('nowheretobefound.xml')
]]>
      </cmdline>
    </command>
    <command xsi:type="command_list" maxparallel="4">
      <command xsi:type="command_python">
        <cmdline>
<![CDATA[
import time
print '6a. start sleep'
time.sleep(1)
print '6a. end sleep'
]]>
        </cmdline>
      </command>
      <command xsi:type="command_python">
        <cmdline>
<![CDATA[
import time
print '6b. start sleep'
time.sleep(1)
print '6b. end sleep'
]]>
        </cmdline>
      </command>
      <command xsi:type="command_system">
        <cmdline>echo 6c. start sleep &amp;&amp; sleep 1&amp;&amp; echo 6c. after sleep</cmdline>
      </command>
    </command>
    <command xsi:type="command_save">
      <filename>output.1.xml</filename>
    </command>

<!-- A simple user interface. -->
<!--
    <command xsi:type="command_python">
        <cmdline>
<![CDATA[
import Tkinter

def post_xml():
  t.insert(Tkinter.end,"<PLAN>\n</plan>")

root = Tkinter.Tk("Frepple","Frepple")
Tkinter.Label(text="Edit your xml message", anchor=Tkinter.W).pack()
s = Tkinter.Scrollbar(root)
t = Tkinter.Text(root)
t.insert(Tkinter.end,"<PLAN>\n</plan>")
t.focus_set()
Tkinter.Button(text="exit", command=sys.exit).pack(side=Tkinter.BOTTOM,fill=Tkinter.NONE)
Tkinter.Button(text="submit", command=post_xml).pack(side=Tkinter.BOTTOM,fill=Tkinter.NONE)
Tkinter.Entry(state=Tkinter.DISABLED).pack(side=Tkinter.BOTTOM,fill=Tkinter.NONE)
s.pack(side=Tkinter.RIGHT, fill=Tkinter.Y)
t.pack(side=Tkinter.LEFT, expand=True, fill=Tkinter.BOTH)
s.config(command=t.yview)
t.config(yscrollcommand=s.set)
#Tkinter.Entry(state=Tkinter.DISABLED).pack()
Tkinter.mainloop()
]]>
      </cmdline>
    </command>
-->

<!-- A simple web server. -->
<!--
    <command xsi:type="command_python">
        <cmdline>
<![CDATA[
import SimpleHTTPServer,SocketServer, frepple
PORT = 8000

class FreppleServer(SimpleHTTPServer.SimpleHTTPRequestHandler):
  def do_HEAD(self):
    # Headers
    self.send_header("Content-type", "application/xml")
    self.send_header("Cache-Control", "no-cache")
    self.end_headers()
  def do_GET(self):
    # Body
    try:
      # Return the complete model as an XML page
      # For large models this will blow up browser: the xml data
      # are being loaded in a DOM tree, consuming plenty of memory...
      self.wfile.write(frepple.saveXMLstring())
    except:
      self.send_error(500, "Exception when saving the model")

print "started HTTP server on port ", PORT
print "Point your browser to http://localhost:" + str(PORT) + " to see the pages."
print "Use ctrl-c to exit..."
SocketServer.TCPServer(("", PORT), FreppleServer).serve_forever()
]]>
      </cmdline>
    </command>
-->

<!-- An interactive debugging prompt. -->
<!--
    <command xsi:type="command_python">
      <cmdline>
<![CDATA[
import code
code.interact("Interactive debugging prompt (use CTRL-Z to exit)")
]]>
      </cmdline>
    </command>
-->

  </commands>
  <?python print "2. Python processing instructions are executed before the commands" ?>
</plan>
