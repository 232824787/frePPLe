#!/usr/bin/perl
#  file     : $HeadURL: file:///develop/SVNrepository/frepple/trunk/test/scalability_2/runtest.pl $
#  revision : $LastChangedRevision$  $LastChangedBy$
#  date     : $LastChangedDate$
#  email    : jdetaeye@users.sourceforge.net


# This script is a simple, generic model generator. A number of different
# models are created with varying number of clusters, depth of the supply path
# and number of demands per cluster. By evaluating the runtime of these models
# we can evaluate different aspects of Frepple's scalability.
#
# This test script is meant more as a sample for your own tests on evaluating
# scalability.
#
# The autogenerated supply network looks schematically as follows:
#   [ Operation -> buffer ] ...   [ -> Operation -> buffer ]  [ Delivery ]
#   [ Operation -> buffer ] ...   [ -> Operation -> buffer ]  [ Delivery ]
#   [ Operation -> buffer ] ...   [ -> Operation -> buffer ]  [ Delivery ]
#   [ Operation -> buffer ] ...   [ -> Operation -> buffer ]  [ Delivery ]
#   [ Operation -> buffer ] ...   [ -> Operation -> buffer ]  [ Delivery ]
#       ...                                  ...
# Each row represents a cluster.
# The operation+buffer are repeated as many times as the depth of the supply
# path parameter.
# In each cluster a single item is defined, and a parametrizable number of
# demands is placed on the cluster.


use strict;
use warnings;

use Env qw(EXECUTABLE);
use Time::HiRes qw ( gettimeofday tv_interval );



# This function generates a random date
sub getDate()
{
  my ($month,$day) = ( int(rand(12)+1), int(rand(28)+1) );
  if ($month < 10) { $month = "0$month"; }
  if ($day < 10) { $day = "0$day"; }
  return "2006-${month}-${day}T00:00:00";
}


# This routine creates the model data file.
# The return value is an indication of the size of the model.
sub create ($;$;$)
{
  # Pick up the parameters
  my ($cluster,$demand,$level) = @_;

  # Initialize
  my $size = 0;
  open(OUT, ">input.xml");
  print OUT "<PLAN xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n";

  # Items
  print OUT "<ITEMS>\n";
  for (my $i=1; $i<=$cluster; $i+=1)
  {
    $size++;
    print OUT "<ITEM NAME=\"Item C$i\">" .
      "<OPERATION NAME=\"Del C$i\"> <FLOWS>" .
        "<FLOW xsi:type=\"FLOW_START\" QUANTITY=\"-1\">" .
        "<BUFFER NAME=\"Buffer C${i}L1\"/></FLOW>" .
      "</FLOWS></OPERATION></ITEM>\n";
  }
  print OUT "</ITEMS>\n";

  # Demands
  print OUT "<DEMANDS>\n";
  for (my $i=1; $i<=$cluster; $i+=1)
  {
    for (my $j=1; $j<=$demand; $j+=1)
    {
      $size += 2; # since a demand will result in multiple operationplans
      print OUT "<DEMAND NAME=\"Demand C${i}D${j}\" " .
        "QUANTITY=\"1\" DUE=\"" . getDate() . "\">" .
        "<ITEM NAME=\"Item C$i\"/></DEMAND>\n";
    }
  }
  print OUT "</DEMANDS>\n";

  # Operations
  print OUT "<OPERATIONS>\n";
  for (my $i=1; $i<=$cluster; $i+=1)
  {
    for (my $j=1; $j<=$level; $j+=1)
    {
      $size += 2;
      my $k = $j + 1;
      print OUT "<OPERATION NAME=\"Oper C${i}O${j}\" " .
        "xsi:type=\"OPERATION_FIXED_TIME\" " .
        "DURATION=\"" . (24*int(rand(10)+1)) . ":00:00\"> <FLOWS>" .
        "<FLOW xsi:type=\"FLOW_END\" QUANTITY=\"1\">" .
        "<BUFFER NAME=\"Buffer C${i}L${j}\">" .
        "<PRODUCING NAME=\"Oper C${i}O${j}\"/></BUFFER></FLOW>" .
        "<FLOW xsi:type=\"FLOW_START\" QUANTITY=\"-1\">" .
        "<BUFFER NAME=\"Buffer C${i}L${k}\"/></FLOW>" .
        "</FLOWS></OPERATION>\n";
    }
  }

  # Create material supply
  my $supplylevel = $level + 1;
  my $supplyqty = $demand;
  for (my $i=1; $i<=$cluster; $i+=1)
  {
    print OUT "<OPERATION NAME=\"Supply C${i}\"> " .
        "<FLOWS><FLOW xsi:type=\"FLOW_END\" QUANTITY=\"1\">" .
        "<BUFFER NAME=\"Buffer C${i}L${supplylevel}\"/>" .
        "</FLOW></FLOWS></OPERATION>";
  }
  print OUT "</OPERATIONS>\n<OPERATION_PLANS>\n";
  for (my $i=1; $i<=$cluster; $i+=1)
  {
    print OUT "<OPERATION_PLAN ID=\"${i}\" OPERATION=\"Supply C${i}\" " .
        "START=\"2006-05-01T00:00:00\" QUANTITY=\"${supplyqty}\" " .
        "LOCKED=\"true\" />\n";
  }
  print OUT "</OPERATION_PLANS>";

  # Tail of the output file
  print OUT "</PLAN>\n";
  close(OUT);

  # Return size indication
  return $size;
}


# Values to loop through
my @clusters = (100, 200, 300);
my @levels = (1, 5, 9);
my @demands = (10, 20, 30);
my %runtimes;

# Initialize random number generator in a reproducible way
srand(100);

# Loop over all cluster values
print "Clusters\tDemands\tLevels\tRuntime\n";
foreach my $cluster (@clusters) {

  # Loop over all demand values
  foreach my $demand (@demands) {

    # Loop over all level values
    foreach my $level (@levels) {

      # Creating model data file
      my $size = create($cluster, $demand, $level);

      # Run the model
      my $starttime = [gettimeofday];
      system("$EXECUTABLE ./commands.xml");
      die "Planner exited abnormally\n" if $? ne 0;

      # Measure the time
      $runtimes{$size} = tv_interval($starttime);
      printf "$cluster\t$demand\t$level\t%.3f\n", $runtimes{$size};

      # Clean up the files
      unlink "input.xml";
      unlink "output.xml";
      #rename "input.xml", "input_${cluster}_${demand}_${level}.xml";
      #rename "output.xml", "output_${cluster}_${demand}_${level}.xml";

    }
  }
}

# A pass criterium could be defined here.
# Right now the test pass when all cases finish successfully, and the timing
# isn't considered to evaluate pass or fail.
# Since the data import and bottleneck are the most timeconsuming operations
# a timing that scales close to linear with the model size is expected.

print "\nTest passed\n";
exit;
