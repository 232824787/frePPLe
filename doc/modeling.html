<html>
<head>
<meta http-equiv="Content-Type" content="text/html">
<title>Modeling</title>
<link href="styles.css" rel="stylesheet" type="text/css">
</head>
<body>
<H1>Modeling</H1>
<p>This page describes in detail the class hierarchy of the framework and the
structure of the XML documents it processes.</p>
<p>The intended audience includes a) people generating the data content in
XML-structures and b) C++ developers who need to understand the classes
for extending the framework. For both uses we assume the reader is familiar with
the
generic <a href="modeling_concepts.html">modeling concepts</a> before starting
this document.</p>
<p>UNFINISHED DOCUMENTATION!!!</p>
<ul>
<li><a href="#utility">Utility classes</a></li>
	<ul>
	<li><a href="#command">Command</li>
	<li><a href="#timer">Timer</li>
	<li><a href="#factory">Object factory</li>
	<li><a href="#date">Date - DateRange - TimePeriod</li>
	<li><a href="#serialization">Serialization</li>
	</ul>
<li><a href="#abstractmodel">Abstract Model classes</a></li>
<li><a href="#staticmodel">Static model classes</a></li>
<li><a href="#dynamicmodel">Dynamic model classes</a></li>
</ul>

<H2><a name="utility"/>Utility classes</H2>
A number of utility classes are supporting the modeling framework with very
common and generic functionality.

<H3><a name="command"/>Command</H3>
This class implements the well-known command design pattern. All main actions
happening in the application have been encapsulated in objects of this class.
This design has the advantage of seperating the core modeling and the model
manipulation (a la Model-Viewer-Controller).
The main methods are:
<ul>
<li>execute(): performs the action.</li>
<li>undo(): undoes the action, if possible</li>
</ul>
Subclasses of the command class are:
<ul>
<li>CommandList
<p>Following the composite design pattern, this command type works as a wrapper
for
a collection of other commands. This allows complete command hierarchies to be
constructed. The commands are executed in sequence. The field AbortOnError
controls the
behavior in case one of the commands in the sequence fails: continue processing
the next command, or abort the complete list of commands.
</p></li>
<li></li>
</ul>

<H3><a name="date"/>Date - DateRange - TimePeriod</H3>
These classes allow easy and intuitive manipulation of dates, durations and date
ranges.
Internally the classes are implemented as a thin wrapper around the standard
ansi C time functions. This provides time accuracy of 1 second.
An example is the best way to describe the functionality:

<H3><a name="timer"/>Timer</H3>
This is a function to measure the excution time of the application with
millisecond precision.
<pre>
  Timer t;
  do_something();
  cout << "something took " << t << " seconds" << endl;
  t.restart();
  do_antotherthing();
  cout << "antotherthing took " << t << " seconds" << endl;
</pre>
<H3><a name="factory"/>Object factory</H3>

<H3><a name="observer"/>Observer -  Subject</H3>

<H3><a name="serialization"/>Serialization</H3>


<H2><a name="abstractmodel">Abstract Model classes</H2>
A number of classes are providing some foundation functionality for the model.

<H3><a name="named"/>Named</H3>
"Things" have a name and we use names all over the place to create, find, refer
to "things". This class is a template class that

<H3><a name="entity"/>Entity</a></H3>
Entity is another template class that is derived from the Named class. In
addition to having a name, this class allows for "things" to:
<ul>
<li>belong to a hierachical structure</li>
<li>have a description, category and subcategory string. These are used as
information-only fields that have no predefined meaning in the model.
Interpretation and usage of these fields is left open for implementations.</li>
</ul>

<H3><a name="plannable"/>Plannable - Solver</H3>

<H3><a name="leveled"/>Leveled</H3>
The model classes Operation, Buffer, Resource, Load and Flow are the key objects
that are used to represent the network. The first three represent the actual
entities, while Load and Flow represent associations/links between the entities.
In such a network we can easily recognize the concepts of:
<ul>
<li><B>Cluster</B></li>
Some objects are linked to each other, i.e. a path along associatons exists that
connects boths entities. Other entities are completely independent of each
other.
Each independent set of connected entities is given a seperate identifying
number.
The cluster concept allows us to classify entities and enable multithreading:
since the clusters are independent we can use different threads to solve each
cluster.

<li><B>Level</B></li>
Operations consume certain materials. These materials are built or procured by
other operations. This creates a sense of direction in our network which is
expressed by the level concept.
</ul>

<H2><a name="staticmodel">Static model classes</H2>

<H3><a name="operation"/>Operation</a></H3>
<ul>
<li></li>
</ul>

<H3><a name="buffer"/>Buffer</a></H3>
A buffer represents a combination of a item and location. It is the entity
for keeping modeling inventory.
A synonyme is SKU or stock-keeping-unit.

<H3><a name="resource"/>Resource</a></H3>
A resource represents a workcentre, a physical or logical representation
of capacity.

<H3><a name="load"/>Load</a></H3>
A load links a resource to a certain operation.

<H3><a name="flow"/>Flow</a></H3>
A flow represent the production or consumption of material from a buffer.
A flow is attached to an operation.

<H3><a name="item"/>Item</a></H3>
An item defines the products being planned, sold, stored and/or manufactured.
Buffers and demands have a reference an item.

<H3><a name="location"/>Location</a></H3>
Buffers and resources are linked to a (physical or logical) location.
Locations are merely used for simple association, and have no active use in the
model.

<H3><a name="calendar"/>Calendar</a></H3>
A calendar is used to represent time dependent parameters.

<H3>Customer</H3>
Demand is linked to a customer. This association currently has no further
active use in the model.

<H2><a name="dynamicmodel">Dynamic model classes</H2>

<H3>Plan</H3>

<H3>Demand</H3>
A demand represents a independent demand to be planned. It can represent a
customer order or a forecast.

<H3>Operationplan</H3>
Operationplans are created by the factory method createOperationPlan() on the
matching operation class. Next in the lifecycle the createLoadAndFlowplans() can
optionally be called to also create the loadplans and flowplans. Once you're
sure about creating the operationplan, the initialize() method should be called.
It will assign the operationplan a unique numeric identifier, register the
operationplan in a global container, and also create loadplans and flowplans if
this hasn't been done yet.
Operationplans can be organized in hierarchical structure, mimicing the
operation hierarchies they match with.

<H3>Loadplan</H3>

<H3>Flowplan</H3>

<H3>Problem</H3>
Problems are objects representing infeasibilities in the plan or other
situations requiring the users' attention.
The problems are created in a "lazy" way. This means that the problems in the
plan are only detected (and corresponding problem objects created) when these
are requested by the user. During normal planning activities we merely mark the
planning entities that have changed, so we can easily which problems to
recompute. In this way we can avoid the cpu and memory overhead of keeping the
problem list up to date at all times, while at the same moment still providing
the user with the correct problem list when required.
Creation and destruction of the problem objects is the responsability of the
</body>
</html>
